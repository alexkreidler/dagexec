// Code generated by go-enum
// DO NOT EDIT!

package lib

import (
	"fmt"
	"strings"
)

const (
	// StateStart is a State of type Start
	StateStart State = iota + 1
	// StateWaiting is a State of type Waiting
	StateWaiting
	// StateRunning is a State of type Running
	StateRunning
	// StateFailed is a State of type Failed
	StateFailed
	// StateSucceeded is a State of type Succeeded
	StateSucceeded
)

const _StateName = "startWaitingRunningFailedSucceeded"

var _StateMap = map[State]string{
	1: _StateName[0:5],
	2: _StateName[5:12],
	3: _StateName[12:19],
	4: _StateName[19:25],
	5: _StateName[25:34],
}

// String implements the Stringer interface.
func (x State) String() string {
	if str, ok := _StateMap[x]; ok {
		return str
	}
	return fmt.Sprintf("State(%d)", x)
}

var _StateValue = map[string]State{
	_StateName[0:5]:                    1,
	strings.ToLower(_StateName[0:5]):   1,
	_StateName[5:12]:                   2,
	strings.ToLower(_StateName[5:12]):  2,
	_StateName[12:19]:                  3,
	strings.ToLower(_StateName[12:19]): 3,
	_StateName[19:25]:                  4,
	strings.ToLower(_StateName[19:25]): 4,
	_StateName[25:34]:                  5,
	strings.ToLower(_StateName[25:34]): 5,
}

// ParseState attempts to convert a string to a State
func ParseState(name string) (State, error) {
	if x, ok := _StateValue[name]; ok {
		return x, nil
	}
	return State(0), fmt.Errorf("%s is not a valid State", name)
}

// MarshalText implements the text marshaller method
func (x *State) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *State) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseState(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
